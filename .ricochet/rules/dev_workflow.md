---
description: Руководство по использованию Ricochet для управления задачами в процессе разработки
globs: **/*
alwaysApply: true
---
# Рабочий процесс разработки с Ricochet

Это руководство описывает типичный процесс использования Ricochet для управления задачами проекта в процессе разработки.

## Основные способы взаимодействия с Ricochet

Ricochet предлагает два основных способа взаимодействия:

1.  **MCP-сервер (рекомендуется для интегрированных инструментов)**:
    - Для ИИ-агентов и интегрированных сред разработки (таких как Cursor) взаимодействие через **MCP-сервер является предпочтительным методом**.
    - MCP-сервер предоставляет функциональность Ricochet через набор инструментов (например, `get_tasks`, `add_subtask`).
    - Этот метод обеспечивает лучшую производительность, структурированный обмен данными и более богатую обработку ошибок по сравнению с парсингом CLI.
    - Подробности о MCP-архитектуре и доступных инструментах можно найти в файле [`mcp.md`](mdc:.ricochet/rules/mcp.md).
    - Полный список и описание инструментов MCP и соответствующих им команд CLI можно найти в [`ricochet.md`](mdc:.ricochet/rules/ricochet.md).
    - **Перезапустите MCP-сервер**, если изменилась основная логика в `scripts/modules` или определения инструментов MCP/прямых функций.

2.  **CLI-команда `ricochet` (для пользователей и в качестве запасного варианта)**:
    - Глобальная команда `ricochet` предоставляет удобный интерфейс для прямого взаимодействия через терминал.
    - Она также может служить запасным вариантом, если MCP-сервер недоступен или определенная функция не предоставляется через MCP.
    - Устанавливайте глобально через `go install github.com/grik-ai/ricochet-task` или используйте локально.
    - Команды CLI часто соответствуют инструментам MCP (например, `ricochet list` соответствует `get_tasks`).
    - Подробное описание команд можно найти в [`ricochet.md`](mdc:.ricochet/rules/ricochet.md).

## Стандартный рабочий процесс разработки

-   Начинайте новые проекты, запуская инструмент `initialize_project` / команду `ricochet init` или `parse_prd` / `ricochet parse-prd --input='<prd-file.txt>'` для генерации начального tasks.json
-   Начинайте сессии кодирования с `get_tasks` / `ricochet list`, чтобы увидеть текущие задачи, их статусы и ID
-   Определяйте следующую задачу для работы с помощью `next_task` / `ricochet next`
-   Анализируйте сложность задач с помощью `analyze_project_complexity` / `ricochet analyze-complexity --research` перед их разбиением
-   Просматривайте отчет о сложности с помощью `complexity_report` / `ricochet complexity-report`
-   Выбирайте задачи на основе зависимостей (все отмеченные как 'done'), уровня приоритета и порядка ID
-   Уточняйте задачи, проверяя файлы задач в каталоге tasks/ или запрашивая ввод пользователя
-   Просматривайте детали конкретной задачи с помощью `get_task` / `ricochet show <id>`, чтобы понять требования к реализации
-   Разбивайте сложные задачи с помощью `expand_task` / `ricochet expand --id=<id> --force --research` с соответствующими флагами, такими как `--force` (для замены существующих подзадач) и `--research`
-   При необходимости очищайте существующие подзадачи с помощью `clear_subtasks` / `ricochet clear-subtasks --id=<id>` перед повторной генерацией
-   Реализуйте код в соответствии с деталями задачи, зависимостями и стандартами проекта
-   Проверяйте задачи в соответствии со стратегиями тестирования перед отметкой их как завершенных
-   Отмечайте завершенные задачи с помощью `set_task_status` / `ricochet set-status --id=<id> --status=done`
-   Обновляйте зависимые задачи, когда реализация отличается от первоначального плана, используя `update` / `ricochet update --from=<id> --prompt="..."` или `update_task` / `ricochet update-task --id=<id> --prompt="..."`
-   Добавляйте новые задачи, обнаруженные в процессе реализации, с помощью `add_task` / `ricochet add-task --prompt="..." --research`
-   Добавляйте новые подзадачи по мере необходимости с помощью `add_subtask` / `ricochet add-subtask --parent=<id> --title="..."`
-   Добавляйте заметки или детали к подзадачам с помощью `update_subtask` / `ricochet update-subtask --id=<subtaskId> --prompt='Добавить заметки по реализации...\nБольше деталей...'`
-   Генерируйте файлы задач с помощью `generate` / `ricochet generate` после обновления tasks.json
-   Поддерживайте правильную структуру зависимостей с помощью инструментов `add_dependency`/`remove_dependency` или команд `ricochet add-dependency`/`remove-dependency`, `validate_dependencies` / `ricochet validate-dependencies` и `fix_dependencies` / `ricochet fix-dependencies` при необходимости
-   Соблюдайте цепочки зависимостей и приоритеты задач при выборе работы
-   Регулярно сообщайте о прогрессе с помощью `get_tasks` / `ricochet list`
-   При необходимости реорганизуйте задачи с помощью `move_task` / `ricochet move --from=<id> --to=<id>` для изменения иерархии или порядка задач

## Анализ сложности задач

-   Запустите `analyze_project_complexity` / `ricochet analyze-complexity --research` для комплексного анализа
-   Просмотрите отчет о сложности через `complexity_report` / `ricochet complexity-report` для получения форматированной, читаемой версии.
-   Сосредоточьтесь на задачах с наивысшими показателями сложности (8-10) для детальной разбивки
-   Используйте результаты анализа для определения подходящего распределения подзадач
-   Обратите внимание, что отчеты автоматически используются инструментом/командой `expand_task`

## Процесс разбивки задач

-   Используйте `expand_task` / `ricochet expand --id=<id>`. Он автоматически использует отчет о сложности, если таковой найден, иначе генерирует стандартное количество подзадач.
-   Используйте `--num=<number>` для указания явного количества подзадач, переопределяя стандартные значения или рекомендации отчета о сложности.
-   Добавьте флаг `--research` для использования ИИ-исследования при расширении.
-   Добавьте флаг `--force` для очистки существующих подзадач перед генерацией новых (по умолчанию подзадачи добавляются).
-   Используйте `--prompt="<context>"` для предоставления дополнительного контекста при необходимости.
-   Просматривайте и корректируйте сгенерированные подзадачи при необходимости.
-   Используйте инструмент `expand_all` или `ricochet expand --all` для расширения нескольких ожидающих задач одновременно, с учетом флагов, таких как `--force` и `--research`.
-   Если подзадачи требуют полной замены (независимо от флага `--force` в `expand`), сначала очистите их с помощью `clear_subtasks` / `ricochet clear-subtasks --id=<id>`.

## Управление изменениями в реализации

-   Когда реализация существенно отличается от запланированного подхода
-   Когда будущие задачи требуют модификации из-за текущих выборов реализации
-   Когда возникают новые зависимости или требования
-   Используйте `update` / `ricochet update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` для обновления нескольких будущих задач.
-   Используйте `update_task` / `ricochet update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` для обновления отдельной конкретной задачи.

## Управление статусами задач

-   Используйте 'pending' для задач, готовых к работе
-   Используйте 'done' для завершенных и проверенных задач
-   Используйте 'deferred' для отложенных задач
-   Добавляйте пользовательские значения статуса по мере необходимости для специфических рабочих процессов проекта

## Поля структуры задачи

- **id**: Уникальный идентификатор задачи (Пример: `1`, `1.1`)
- **title**: Краткое, описательное название (Пример: `"Инициализация репозитория"`)
- **description**: Краткое резюме того, что включает задача (Пример: `"Создать новый репозиторий, настроить начальную структуру."`)
- **status**: Текущее состояние задачи (Пример: `"pending"`, `"done"`, `"deferred"`)
- **dependencies**: ID задач-предпосылок (Пример: `[1, 2.1]`)
    - Зависимости отображаются с индикаторами статуса (✅ для завершенных, ⏱️ для ожидающих)
    - Это помогает быстро определить, какие задачи-предпосылки блокируют работу
- **priority**: Уровень важности (Пример: `"high"`, `"medium"`, `"low"`)
- **details**: Углубленные инструкции по реализации (Пример: `"Использовать GitHub client ID/secret, обработать callback, установить session token."`) 
- **testStrategy**: Подход к верификации (Пример: `"Развернуть и вызвать конечную точку для подтверждения ответа 'Hello World'."`) 
- **subtasks**: Список меньших, более конкретных задач (Пример: `[{"id": 1, "title": "Настроить OAuth", ...}]`) 

## Определение следующей задачи

- Запустите `next_task` / `ricochet next`, чтобы показать следующую доступную задачу, над которой можно работать.
- Команда идентифицирует задачи со всеми удовлетворенными зависимостями
- Задачи приоритизируются по уровню приоритета, количеству зависимостей и ID
- Команда показывает комплексную информацию о задаче, включая:
    - Основные детали задачи и описание
    - Детали реализации
    - Подзадачи (если они существуют)
    - Контекстуальные предлагаемые действия
- Рекомендуется перед началом любой новой разработки
- Учитывает структуру зависимостей вашего проекта
- Обеспечивает выполнение задач в соответствующей последовательности
- Предоставляет готовые к использованию команды для общих действий с задачами

## Просмотр деталей конкретной задачи

- Запустите `get_task` / `ricochet show <id>` для просмотра конкретной задачи.
- Используйте точечную нотацию для подзадач: `ricochet show 1.2` (показывает подзадачу 2 задачи 1)
- Отображает комплексную информацию, аналогичную команде next, но для конкретной задачи
- Для родительских задач показывает все подзадачи и их текущий статус
- Для подзадач показывает информацию о родительской задаче и отношениях
- Предоставляет контекстуальные предлагаемые действия, соответствующие конкретной задаче
- Полезно для изучения деталей задачи перед реализацией или проверки статуса

## Управление зависимостями задач

- Используйте `add_dependency` / `ricochet add-dependency --id=<id> --depends-on=<id>` для добавления зависимости.
- Используйте `remove_dependency` / `ricochet remove-dependency --id=<id> --depends-on=<id>` для удаления зависимости.
- Система предотвращает циклические зависимости и дублирование записей зависимостей
- Зависимости проверяются на существование перед добавлением или удалением
- Файлы задач автоматически регенерируются после изменений зависимостей
- Зависимости визуализируются с индикаторами статуса в списках задач и файлах

## Реорганизация задач

- Используйте `move_task` / `ricochet move --from=<id> --to=<id>` для перемещения задач или подзадач в иерархии
- Эта команда поддерживает несколько сценариев использования:
  - Перемещение отдельной задачи для превращения в подзадачу (например, `--from=5 --to=7`)
  - Перемещение подзадачи для превращения в отдельную задачу (например, `--from=5.2 --to=7`) 
  - Перемещение подзадачи к другому родителю (например, `--from=5.2 --to=7.3`)
  - Переупорядочение подзадач в рамках одного родителя (например, `--from=5.2 --to=5.4`)
  - Перемещение задачи на новую, несуществующую позицию ID (например, `--from=5 --to=25`)
  - Перемещение нескольких задач одновременно с использованием ID, разделенных запятыми (например, `--from=10,11,12 --to=16,17,18`)
- Система включает валидацию для предотвращения потери данных:
  - Позволяет перемещать к несуществующим ID путем создания задач-заполнителей
  - Предотвращает перемещение к существующим ID задач, которые уже имеют содержимое (чтобы избежать перезаписи)
  - Проверяет существование исходных задач перед попыткой их перемещения
- Система поддерживает правильные отношения родитель-ребенок и целостность зависимостей
- Файлы задач автоматически регенерируются после операции перемещения
- Это обеспечивает большую гибкость в организации и уточнении структуры ваших задач по мере развития понимания проекта

## Итеративная реализация подзадач

После разбивки задачи на подзадачи с использованием `expand_task` или аналогичных методов, следуйте этому итеративному процессу для реализации:

1.  **Понимание цели (подготовка):**
    *   Используйте `get_task` / `ricochet show <subtaskId>` для полного понимания конкретных целей и требований подзадачи.

2.  **Начальное исследование и планирование (итерация 1):**
    *   Это первая попытка создания конкретного плана реализации.
    *   Исследуйте кодовую базу для определения точных файлов, функций и даже конкретных строк кода, которые потребуют модификации.
    *   Определите предполагаемые изменения кода (различия) и их местоположения.
    *   Соберите *все* релевантные детали из этой фазы исследования.

3.  **Запись плана:**
    *   Запустите `update_subtask` / `ricochet update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
    *   Предоставьте *полные и детальные* результаты из фазы исследования в запросе. Включите пути к файлам, номера строк, предлагаемые изменения, обоснование и любые потенциальные сложности, которые были выявлены. Не опускайте детали. Цель состоит в создании богатого, снабженного временными метками журнала в `details` подзадачи.

4.  **Проверка плана:**
    *   Запустите `get_task` / `ricochet show <subtaskId>` снова, чтобы подтвердить, что детальный план реализации был успешно добавлен к деталям подзадачи.

5.  **Начало реализации:**
    *   Установите статус подзадачи с помощью `set_task_status` / `ricochet set-status --id=<subtaskId> --status=in-progress`.
    *   Начните кодирование на основе записанного плана.

6.  **Уточнение и запись прогресса (итерация 2+):**
    *   По мере продвижения реализации вы будете сталкиваться с сложностями, обнаруживать нюансы или подтверждать успешные подходы.
    *   **Перед добавлением новой информации**: Кратко просмотрите *существующие* детали, записанные в подзадаче (с помощью `get_task` или вспоминая из контекста), чтобы убедиться, что обновление добавляет свежие идеи и избегает избыточности.
    *   **Регулярно** используйте `update_subtask` / `ricochet update-subtask --id=<subtaskId> --prompt='<update details>\n- Что сработало...\n- Что не сработало...'` для добавления новых результатов.
    *   **Обязательно записывайте:**
        *   Что сработало ("фундаментальные истины", которые были обнаружены).
        *   Что не сработало и почему (чтобы избежать повторения ошибок).
        *   Конкретные фрагменты кода или конфигурации, которые были успешными.
        *   Принятые решения, особенно если они подтверждены вводом пользователя.
        *   Любые отклонения от первоначального плана и обоснование.
    *   Цель состоит в постоянном обогащении деталей подзадачи, создавая журнал пути реализации, который помогает ИИ (и разработчикам-людям) учиться, адаптироваться и избегать повторения ошибок.

7.  **Отметка задачи как завершенной:**
    *   После проверки реализации отметьте подзадачу как завершенную: `set_task_status` / `ricochet set-status --id=<subtaskId> --status=done`.

8.  **Переход к следующей подзадаче:**
    *   Определите следующую подзадачу (например, с использованием `next_task` / `ricochet next`).

---
*Этот рабочий процесс предоставляет общее руководство. Адаптируйте его на основе конкретных потребностей вашего проекта и практик команды.* 